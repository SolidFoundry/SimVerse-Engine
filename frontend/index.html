<!-- frontend/index.html (å‰ç«¯æ¸²æŸ“å®¢æˆ·ç«¯) -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimVerse Engine - å®æ—¶æ¨¡æ‹Ÿ</title>
    <style>
        body {
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #container {
            width: 1280px;
            padding: 20px;
            background-color: #2e2e4f;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 0 10px;
        }
        #header h1 {
            font-size: 24px;
            margin: 0;
            display: flex;
            align-items: center;
        }
        #header h1 span { margin-left: 10px; }
        #connection-status {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .connected {
            background-color: rgba(3, 201, 136, 0.1);
            color: #03c988;
        }
        .connected .status-dot { background-color: #03c988; }
        .disconnected {
            background-color: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }
        .disconnected .status-dot { background-color: #dc3545; }
        
        /* æ¸¸æˆåœºæ™¯æ ¸å¿ƒæ ·å¼ */
        #scene {
            position: relative;
            width: 1280px; /* å°†ä¼šè¢«èƒŒæ™¯å›¾å®é™…å°ºå¯¸è¦†ç›– */
            height: 720px;  /* å°†ä¼šè¢«èƒŒæ™¯å›¾å®é™…å°ºå¯¸è¦†ç›– */
            background-image: url('../assets/game-map.png'); /* å¼•ç”¨èƒŒæ™¯å›¾ */
            background-size: cover;
            border-radius: 8px;
            overflow: hidden; /* é˜²æ­¢NPCç§»å‡ºè¾¹ç•Œ */
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #4a4a70;
        }
        /* NPCé€šç”¨æ ·å¼ */
        .npc {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
            /* ç§»é™¤CSS transitionï¼Œæ”¹ç”¨JavaScriptç²¾ç¡®æ§åˆ¶åŠ¨ç”» */
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            /* ç¡®ä¿å¤´åƒå›¾ç‰‡åœ¨åœ†å½¢åŒºåŸŸå†…å®Œç¾æ˜¾ç¤º */
            overflow: hidden;
        }
        .npc-label {
            position: absolute;
            bottom: -20px; /* æ ‡ç­¾åœ¨å›¾æ ‡ä¸‹æ–¹ */
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap; /* é˜²æ­¢æ ‡ç­¾æ¢è¡Œ */
        }

        /* ä¸åŒç±»å‹NPCçš„æ ·å¼ - å¢å¼ºè§†è§‰è¾¨è¯†åº¦ */
        .player { 
            background: linear-gradient(135deg, #03a9f4, #0288d1); 
            border: 3px solid #90caf9; 
            box-shadow: 0 0 20px rgba(3, 169, 244, 0.6);
        }
        .guard { 
            background: linear-gradient(135deg, #e53935, #c62828); 
            border: 3px solid #ef9a9a; 
            box-shadow: 0 0 20px rgba(229, 57, 53, 0.6);
        }
        .npc { 
            background: linear-gradient(135deg, #fb8c00, #ef6c00); 
            border: 3px solid #ffcc80; 
            box-shadow: 0 0 20px rgba(251, 140, 0, 0.6);
        }
        /* NPCå¤´åƒå›¾ç‰‡æ ·å¼ */
        .npc-avatar {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            pointer-events: none;
            /* ç¡®ä¿å›¾ç‰‡åœ¨åœ†å½¢å®¹å™¨ä¸­å®Œç¾å±…ä¸­æ˜¾ç¤º */
            display: block;
            /* æ·»åŠ è½»å¾®çš„ç¼©æ”¾ä»¥ç¡®ä¿å¤´åƒå®Œå…¨å¡«å……åœ†å½¢ */
            transform: scale(1.1);
            /* å¹³æ»‘è¿‡æ¸¡æ•ˆæœ */
            transition: transform 0.3s ease;
        }

        /* NPCé€‰ä¸­çŠ¶æ€æ ·å¼ */
        .npc.selected {
            transform: scale(1.2);
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 255, 255, 1);
            }
            100% {
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }

        /* NPCç§»åŠ¨çŠ¶æ€æ ·å¼ */
        .npc[data-state="walking"] {
            opacity: 0.8;
            filter: brightness(1.2);
        }

        /* åœºæ™¯ç‚¹å‡»æç¤ºæ ·å¼ */
        #scene {
            cursor: crosshair;
        }

        #scene.no-selection {
            cursor: default;
        }

        /* æ“ä½œæç¤ºæ ·å¼ */
        .instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1><span>ğŸ® SimVerse å®æ—¶æ¨¡æ‹Ÿ</span></h1>
            <div id="connection-status" class="disconnected">
                <div class="status-dot"></div>
                <span id="status-text">è¿æ¥ä¸­...</span>
            </div>
        </div>
        <!-- æ¸¸æˆåœºæ™¯æ¸²æŸ“åŒº -->
        <div id="scene">
            <div class="instructions">
                ğŸ® <strong>äº¤äº’å¼æ§åˆ¶å™¨</strong><br>
                1. ç‚¹å‡»ä¸€ä¸ªNPCè¿›è¡Œé€‰ä¸­<br>
                2. ç‚¹å‡»åœ°å›¾ä»»æ„ä½ç½®ç§»åŠ¨NPC<br>
                3. å†æ¬¡ç‚¹å‡»NPCå¯å–æ¶ˆé€‰ä¸­
            </div>
        </div>
    </div>
    <script>
        // è°ƒè¯•æ¨¡å¼é…ç½® - è®¾ç½®ä¸ºtrueä»¥å¯ç”¨è¯¦ç»†æ—¥å¿—
        window.DEBUG_MODE = false;
        
        document.addEventListener('DOMContentLoaded', () => {
            const scene = document.getElementById('scene');
            const connectionStatus = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            const npcElements = {}; // å­˜å‚¨NPCçš„DOMå…ƒç´ 
            let ws = null; // WebSocketè¿æ¥
            let clientId = null; // å®¢æˆ·ç«¯ID
            let selectedNpcId = null; // å½“å‰é€‰ä¸­çš„NPC ID

            // --- åŠ¨æ€è®¾ç½®åœºæ™¯å°ºå¯¸ ---
            const mapImage = new Image();
            mapImage.src = '../assets/game-map.png';
            mapImage.onload = () => {
                scene.style.width = `${mapImage.width}px`;
                scene.style.height = `${mapImage.height}px`;
                // æ ¹æ®æ–°å°ºå¯¸è°ƒæ•´å¤–å±‚å®¹å™¨
                document.getElementById('container').style.width = `${mapImage.width + 40}px`;
            };
            mapImage.onerror = () => {
              console.error("èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿ ../assets/game-map.png è·¯å¾„æ­£ç¡®ã€‚å°†ä½¿ç”¨é»˜è®¤å°ºå¯¸ 1280x720ã€‚");
              document.getElementById('container').style.width = '1280px';
            };

            // NPC IDåˆ°å¤´åƒæ–‡ä»¶çš„æ˜ å°„
            const npcAvatarMap = {
                'npc_1': '../assets/player1.png',
                'npc_2': '../assets/player2.png',
                'npc_3': '../assets/guard.png',
                'npc_4': '../assets/merchant.png',
                'npc_5': '../assets/guide.png'
            };

            // NPCç§»åŠ¨çŠ¶æ€ç®¡ç†
            const npcMovementStates = {};
            
            // ç§»åŠ¨é€Ÿåº¦ï¼šæ¯ç§’ç§»åŠ¨çš„åƒç´ æ•°ï¼ˆä¸åç«¯ä¿æŒä¸€è‡´ï¼‰
            const MOVEMENT_SPEED = 100;

            // === äº¤äº’å¼æ§åˆ¶å™¨æ ¸å¿ƒåŠŸèƒ½ ===
            
            /**
             * å¤„ç†åœºæ™¯ç‚¹å‡»äº‹ä»¶
             * @param {MouseEvent} event - é¼ æ ‡ç‚¹å‡»äº‹ä»¶
             */
            async function handleSceneClick(event) {
                // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„NPCï¼Œä¸å¤„ç†ç‚¹å‡»
                if (!selectedNpcId) {
                    return;
                }

                // è·å–ç‚¹å‡»ä½ç½®ç›¸å¯¹äºåœºæ™¯çš„åæ ‡
                const rect = scene.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                try {
                    // å‘é€äº¤äº’å¼ç§»åŠ¨æŒ‡ä»¤åˆ°åç«¯
                    const moveCommand = {
                        npc_id: selectedNpcId,
                        target_x: Math.round(x),
                        target_y: Math.round(y)
                    };

                    const response = await fetch('http://localhost:8000/command/interactive_move', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(moveCommand)
                    });

                    const result = await response.json();

                    if (response.ok) {
                        // å–æ¶ˆNPCé€‰ä¸­çŠ¶æ€
                        deselectNpc();
                    } else {
                        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                        alert(`ç§»åŠ¨å¤±è´¥: ${result.message}`);
                    }
                } catch (error) {
                    console.error('âŒ å‘é€ç§»åŠ¨æŒ‡ä»¤æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    // æ˜¾ç¤ºæ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    let errorMessage = 'å‘é€ç§»åŠ¨æŒ‡ä»¤å¤±è´¥';
                    if (error.name === 'TypeError') {
                        errorMessage += ': ç½‘ç»œè¿æ¥é—®é¢˜æˆ–æœåŠ¡å™¨æ— å“åº”';
                    } else if (error.name === 'AbortError') {
                        errorMessage += ': è¯·æ±‚è¶…æ—¶';
                    } else {
                        errorMessage += `: ${error.message}`;
                    }
                    alert(errorMessage);
                }
            }

            /**
             * å¤„ç†NPCç‚¹å‡»äº‹ä»¶
             * @param {string} npcId - NPCçš„ID
             * @param {MouseEvent} event - é¼ æ ‡ç‚¹å‡»äº‹ä»¶
             */
            function handleNpcClick(npcId, event) {
                event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°åœºæ™¯
                
                const npc = window.GAME_STATE[npcId];
                if (!npc) {
                    console.warn(`âŒ NPC ${npcId} ä¸å­˜åœ¨äºæ¸¸æˆçŠ¶æ€ä¸­`);
                    return;
                }

                // å¦‚æœNPCæ­£åœ¨ç§»åŠ¨ä¸­ï¼Œä¸å…è®¸é€‰ä¸­
                if (npc.state === 'walking') {
                    console.log(`â³ NPC ${npc.name} æ­£åœ¨ç§»åŠ¨ä¸­ï¼Œæ— æ³•é€‰ä¸­`);
                    return;
                }

                // å¦‚æœç‚¹å‡»çš„æ˜¯å·²é€‰ä¸­çš„NPCï¼Œåˆ™å–æ¶ˆé€‰ä¸­
                if (selectedNpcId === npcId) {
                    deselectNpc();
                    return;
                }

                // å–æ¶ˆä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
                deselectNpc();
                
                // é€‰ä¸­æ–°NPC
                selectedNpcId = npcId;
                const npcElement = npcElements[npcId];
                if (npcElement) {
                    npcElement.classList.add('selected');
                    npcElement.style.transform = 'scale(1.2)';
                    npcElement.style.zIndex = '1000';
                    // æ”¹å˜åœºæ™¯å…‰æ ‡æ ·å¼ï¼Œè¡¨ç¤ºå¯ä»¥ç‚¹å‡»ç§»åŠ¨
                    scene.classList.remove('no-selection');
                    // è®°å½•é€‰ä¸­çŠ¶æ€ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    if (window.DEBUG_MODE) {
                        console.log(`âœ… å·²é€‰ä¸­NPC: ${npc.name} (${npcId})`);
                    }
                }
            }

            /**
             * å–æ¶ˆNPCé€‰ä¸­çŠ¶æ€
             */
            function deselectNpc() {
                if (selectedNpcId) {
                    const npcElement = npcElements[selectedNpcId];
                    if (npcElement) {
                        npcElement.classList.remove('selected');
                        npcElement.style.transform = 'scale(1)';
                        npcElement.style.zIndex = '';
                    }
                    // è®°å½•å–æ¶ˆé€‰ä¸­çŠ¶æ€ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    if (window.DEBUG_MODE) {
                        console.log(`âŒ å·²å–æ¶ˆé€‰ä¸­NPC: ${selectedNpcId}`);
                    }
                    selectedNpcId = null;
                    // æ¢å¤åœºæ™¯é»˜è®¤å…‰æ ‡
                    scene.classList.add('no-selection');
                }
            }

            /**
             * è¿æ¥WebSocketæœåŠ¡å™¨
             */
            function connectWebSocket() {
                ws = new WebSocket('ws://localhost:8000/ws');

                ws.onopen = () => {
                    // è®°å½•è¿æ¥æˆåŠŸï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    if (window.DEBUG_MODE) {
                        console.log('æˆåŠŸè¿æ¥åˆ°SimVerseåç«¯ï¼');
                    }
                    connectionStatus.classList.remove('disconnected');
                    connectionStatus.classList.add('connected');
                    statusText.textContent = 'å·²è¿æ¥';
                };

                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                };

                ws.onclose = () => {
                    // è®°å½•è¿æ¥æ–­å¼€ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    if (window.DEBUG_MODE) {
                        console.log('ä¸åç«¯çš„è¿æ¥å·²æ–­å¼€ï¼Œå°†åœ¨3ç§’åå°è¯•é‡è¿...');
                    }
                    connectionStatus.classList.remove('connected');
                    connectionStatus.classList.add('disconnected');
                    statusText.textContent = 'å·²æ–­å¼€';
                    setTimeout(connectWebSocket, 3000);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket å‘ç”Ÿé”™è¯¯:', error);
                    ws.close();
                };
            }

            /**
             * å¤„ç†æ¥è‡ªåç«¯çš„WebSocketæ¶ˆæ¯
             * @param {Object} message - æ¥æ”¶åˆ°çš„æ¶ˆæ¯å¯¹è±¡
             */
            function handleWebSocketMessage(message) {
                // å¤„ç†è¿æ¥å»ºç«‹æ¶ˆæ¯
                if (message.action === 'connection_established') {
                    clientId = message.client_id;
                    // è®°å½•è¿æ¥ä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                    if (window.DEBUG_MODE) {
                        console.log(`ğŸ”— è¿æ¥å·²å»ºç«‹ï¼Œå®¢æˆ·ç«¯ID: ${clientId}`);
                    }
                    // æ›´æ–°æ¸¸æˆçŠ¶æ€
                    if (message.game_state) {
                        window.GAME_STATE = message.game_state;
                        updateScene(message.game_state);
                    }
                }
                // å¤„ç†è·¯å¾„ç§»åŠ¨æŒ‡ä»¤
                else if (message.action === 'move_along_path') {
                    const { npc_id, path } = message.data;
                    executePathMovement(npc_id, path);
                }
                // å¤„ç†çŠ¶æ€æ›´æ–°
                else if (message.action === 'state_update') {
                    updateScene(message.data);
                }
                // å¤„ç†åˆå§‹æ¸¸æˆçŠ¶æ€ï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                else if (typeof message === 'object' && message.npc_1) {
                    window.GAME_STATE = message;
                    updateScene(message);
                }
            }

            /**
             * æ‰§è¡ŒNPCè·¯å¾„ç§»åŠ¨
             * @param {string} npcId - NPCçš„ID
             * @param {Array} path - è·¯å¾„ç‚¹æ•°ç»„
             */
            async function executePathMovement(npcId, path) {
                const npcElement = npcElements[npcId];
                if (!npcElement) {
                    console.warn(`âŒ NPCå…ƒç´  ${npcId} ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡Œç§»åŠ¨`);
                    return;
                }

                // è®¾ç½®NPCç§»åŠ¨çŠ¶æ€
                npcMovementStates[npcId] = true;
                npcElement.isMoving = true;
                
                // å¦‚æœç§»åŠ¨çš„NPCæ˜¯å½“å‰é€‰ä¸­çš„NPCï¼Œå–æ¶ˆé€‰ä¸­
                if (selectedNpcId === npcId) {
                    deselectNpc();
                }

                try {
                    // æ‰§è¡Œè·¯å¾„åŠ¨ç”»
                    await animatePath(npcId, path);
                    console.log(`âœ… NPC ${npcId} è·¯å¾„ç§»åŠ¨å®Œæˆ`);
                } catch (error) {
                    console.error(`âŒ NPC ${npcId} è·¯å¾„ç§»åŠ¨å¤±è´¥:`, error);
                } finally {
                    // æ¢å¤NPCç§»åŠ¨çŠ¶æ€
                    npcMovementStates[npcId] = false;
                    npcElement.isMoving = false;
                }
            }

            /**
             * ä½¿ç”¨Promiseå’ŒsetTimeoutå®ç°ç²¾ç¡®çš„åŠ¨ç”»æ§åˆ¶
             * @param {HTMLElement} element - è¦ç§»åŠ¨çš„DOMå…ƒç´ 
             * @param {number} targetX - ç›®æ ‡Xåæ ‡
             * @param {number} targetY - ç›®æ ‡Yåæ ‡
             * @param {number} duration - åŠ¨ç”»æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
             * @returns {Promise} åŠ¨ç”»å®Œæˆçš„Promise
             */
            function animateMovement(element, targetX, targetY, duration) {
                return new Promise((resolve) => {
                    const startX = parseFloat(element.style.left) || 0;
                    const startY = parseFloat(element.style.top) || 0;
                    const startTime = Date.now();
                    
                    function updatePosition() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // ä½¿ç”¨çº¿æ€§æ’å€¼è®¡ç®—å½“å‰ä½ç½®
                        const currentX = startX + (targetX - startX) * progress;
                        const currentY = startY + (targetY - startY) * progress;
                        
                        // æ›´æ–°å…ƒç´ ä½ç½®
                        element.style.left = `${currentX}px`;
                        element.style.top = `${currentY}px`;
                        
                        if (progress < 1) {
                            // ç»§ç»­åŠ¨ç”»
                            requestAnimationFrame(updatePosition);
                        } else {
                            // åŠ¨ç”»å®Œæˆ
                            resolve();
                        }
                    }
                    
                    updatePosition();
                });
            }

            /**
             * è®©NPCæ²¿ç€è·¯å¾„ç‚¹ç§»åŠ¨çš„åŠ¨ç”»å‡½æ•°
             * @param {string} npcId - NPCçš„ID
             * @param {Array} path - è·¯å¾„ç‚¹æ•°ç»„ï¼Œæ¯ä¸ªç‚¹åŒ…å«xå’Œyåæ ‡
             * @returns {Promise} æ‰€æœ‰ç§»åŠ¨å®Œæˆåçš„Promise
             */
            async function animatePath(npcId, path) {
                const npcElement = npcElements[npcId];
                if (!npcElement) {
                    console.warn(`âŒ NPCå…ƒç´  ${npcId} ä¸å­˜åœ¨ï¼Œæ— æ³•æ‰§è¡ŒåŠ¨ç”»`);
                    return;
                }
                
                try {
                    // é€ä¸ªç§»åŠ¨åˆ°æ¯ä¸ªè·¯å¾„ç‚¹
                    for (let i = 0; i < path.length; i++) {
                        const waypoint = path[i];
                        const targetX = waypoint.x - 25; // å‡å»NPCå®½åº¦çš„ä¸€åŠï¼Œä½¿ä¸­å¿ƒå¯¹å‡†
                        const targetY = waypoint.y - 25; // å‡å»NPCé«˜åº¦çš„ä¸€åŠï¼Œä½¿ä¸­å¿ƒå¯¹å‡†
                        
                        // è·å–å½“å‰ä½ç½®
                        const currentX = parseFloat(npcElement.style.left) || 0;
                        const currentY = parseFloat(npcElement.style.top) || 0;
                        
                        // è®¡ç®—ç§»åŠ¨è·ç¦»
                        const distance = Math.sqrt(
                            Math.pow(targetX - currentX, 2) + Math.pow(targetY - currentY, 2)
                        );
                        
                        // æ ¹æ®è·ç¦»å’Œé€Ÿåº¦è®¡ç®—åŠ¨ç”»æ—¶é•¿
                        const duration = (distance / MOVEMENT_SPEED) * 1000; // è½¬æ¢ä¸ºæ¯«ç§’
                        
                        if (distance > 0) {
                            // æ‰§è¡Œç§»åŠ¨åŠ¨ç”»
                            await animateMovement(npcElement, targetX, targetY, duration);
                        }
                    }
                    
                    // å‘é€ç§»åŠ¨å®Œæˆä¿¡å·åˆ°åç«¯
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const completeMessage = {
                            event: "move_complete",
                            npc_id: npcId
                        };
                        ws.send(JSON.stringify(completeMessage));
                    }
                    
                } catch (error) {
                    console.error(`âŒ NPC ${npcId} è·¯å¾„åŠ¨ç”»æ‰§è¡Œå¤±è´¥:`, error);
                    // å³ä½¿åŠ¨ç”»å¤±è´¥ï¼Œä¹Ÿè¦å‘é€å®Œæˆä¿¡å·ï¼Œé¿å…NPCçŠ¶æ€å¡ä½
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const completeMessage = {
                            event: "move_complete",
                            npc_id: npcId
                        };
                        ws.send(JSON.stringify(completeMessage));
                    }
                }
            }

            /**
             * æ›´æ–°æ¸¸æˆåœºæ™¯
             * @param {Object} gameState - æ¸¸æˆçŠ¶æ€å¯¹è±¡
             */
            function updateScene(gameState) {
                // æ›´æ–°å…¨å±€æ¸¸æˆçŠ¶æ€
                window.GAME_STATE = gameState;
                
                // éå†åç«¯å‘æ¥çš„æ‰€æœ‰NPCçŠ¶æ€
                for (const npcId in gameState) {
                    const npcState = gameState[npcId];
                    let npcElement = npcElements[npcId];

                    // å¦‚æœåœºæ™¯ä¸­è¿˜æ²¡æœ‰è¿™ä¸ªNPCçš„å…ƒç´ ï¼Œå°±åˆ›å»ºä¸€ä¸ª
                    if (!npcElement) {
                        npcElement = document.createElement('div');
                        npcElement.id = npcId;
                        npcElement.classList.add('npc', npcState.type);
                        npcElement.isMoving = false; // åˆå§‹åŒ–ç§»åŠ¨çŠ¶æ€
                        
                        // åˆ›å»ºå¤´åƒå›¾ç‰‡å…ƒç´ 
                        const avatar = document.createElement('img');
                        avatar.classList.add('npc-avatar');
                        avatar.src = npcAvatarMap[npcId] || '../assets/player1.png'; // é»˜è®¤å¤´åƒ
                        avatar.alt = npcState.name;
                        
                        // åˆ›å»ºåç§°æ ‡ç­¾
                        const label = document.createElement('span');
                        label.classList.add('npc-label');
                        label.textContent = npcState.name;
                        
                        // å°†å¤´åƒå’Œæ ‡ç­¾æ·»åŠ åˆ°NPCå…ƒç´ ä¸­
                        npcElement.appendChild(avatar);
                        npcElement.appendChild(label);
                        scene.appendChild(npcElement);
                        npcElements[npcId] = npcElement;
                        
                        // åˆå§‹åŒ–ç§»åŠ¨çŠ¶æ€
                        npcMovementStates[npcId] = false;
                        
                        // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆå‡å»NPCå°ºå¯¸çš„ä¸€åŠï¼Œä½¿ä¸­å¿ƒå¯¹å‡†ï¼‰
                        npcElement.style.left = `${npcState.x - 25}px`;
                        npcElement.style.top = `${npcState.y - 25}px`;
                        
                        // æ·»åŠ NPCç‚¹å‡»äº‹ä»¶
                        npcElement.addEventListener('click', (e) => handleNpcClick(npcId, e));
                        
                        // æ·»åŠ CSSæ ·å¼è¿‡æ¸¡æ•ˆæœ
                        npcElement.style.transition = 'transform 0.2s ease';
                    }
                    
                    // åªæœ‰åœ¨idleçŠ¶æ€ä¸‹æ‰åŒæ­¥ä½ç½®ï¼ˆwalkingçŠ¶æ€ä¸‹çš„ä½ç½®ç”±åŠ¨ç”»æ§åˆ¶ï¼‰
                    if (npcState.state === 'idle' && !npcMovementStates[npcId]) {
                        // åŒæ­¥ä½ç½®ï¼ˆå‡å»NPCå°ºå¯¸çš„ä¸€åŠï¼Œä½¿ä¸­å¿ƒå¯¹å‡†ï¼‰
                        npcElement.style.left = `${npcState.x - 25}px`;
                        npcElement.style.top = `${npcState.y - 25}px`;
                    }
                    
                    // æ›´æ–°ç§»åŠ¨çŠ¶æ€æ ‡è¯†ï¼ˆç”¨äºè°ƒè¯•æ˜¾ç¤ºï¼‰
                    npcElement.dataset.state = npcState.state;
                    
                    // æ ¹æ®çŠ¶æ€æ›´æ–°NPCå¤–è§‚
                    if (npcState.state === 'walking') {
                        npcElement.style.opacity = '0.8';
                        npcElement.style.filter = 'brightness(1.2)';
                    } else {
                        npcElement.style.opacity = '1';
                        npcElement.style.filter = 'brightness(1)';
                    }
                }
            }

            // æ·»åŠ åœºæ™¯ç‚¹å‡»äº‹ä»¶
            scene.addEventListener('click', handleSceneClick);

            // åˆå§‹åŒ–åœºæ™¯å…‰æ ‡æ ·å¼
            scene.classList.add('no-selection');

            // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
            window.GAME_STATE = {};

            // å¯åŠ¨WebSocketè¿æ¥
            connectWebSocket();
        });
    </script>
</body>
</html>